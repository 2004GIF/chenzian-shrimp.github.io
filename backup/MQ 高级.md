1. 生产者确认机制
   1. 生产者重试 ----> 确保生产者能够连接到 mq 上
   2. 生产者确认 ----> 确保信息发送 mq 上
      1. `Publisher Confirm` 消费者确定 -----> 确保消息发送到 mq 的exchange 上
      2. `Publisher Return`    消费者回退 -----> 确保信息从 exchange 到 queue 上
2. 消息持久化
   1. 在 `SpringAMQP`  中生产者发送的消息都是持久化的
   2. 优化将 消息的队列设置 `Lazy Qqueue` 队列可以确保消息持久化的同时提供mq 的性能
3. 消费者确认机制
   1. 消费者重试机制  ---> 只有当消费者给mq放回 ack 的时候mq才将队列的消息删除
   2. 失败重试处理机制 --->  当消费者的重试机制的耗尽后对消息的处理
4. 业务幂等：一个业务一次处理或者多次处理最终的效果都是一样的，实现方法：
   1. 给每一个消息设置一个唯一的 id ，在执行业务代码前查询数据库是否存在该消息id，不存在  处理完业务将id存储到数据库中 ， 存在，忽略消息即可
   2. 在一些有状态的业务上可以通过判断状态来，决定是否执行该业务
5. 兜底方案
   1.  延迟信息，生产者发送消息到 mq ， 消费不立即消费实现
       1. 死信交换机 
       2. 使用插件，将交换机修改为可以临时存储消息的交换机
  2. 这方案一般用于一些需要有超时取消机制的业务
   

