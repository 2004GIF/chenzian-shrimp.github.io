<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>陈子安个人博客</title><link>https://2004GIF.github.io/chenzian-shrimp.github.io</link><description>每日分享</description><copyright>陈子安个人博客</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://2004GIF.github.io/chenzian-shrimp.github.io</link></image><lastBuildDate>Fri, 28 Jun 2024 11:37:38 +0000</lastBuildDate><managingEditor>陈子安个人博客</managingEditor><ttl>60</ttl><webMaster>陈子安个人博客</webMaster><item><title>网关-动态路由</title><link>https://2004GIF.github.io/chenzian-shrimp.github.io/post/wang-guan---dong-tai-lu-you.html</link><description># 网关-动态路由&#13;
实现思路：&#13;
1. 监听nacos配置文件&#13;
2. 更新网关的路由表&#13;
````java&#13;
package com.hmall.gateway.router;&#13;
&#13;
import cn.hutool.json.JSONUtil;&#13;
import com.alibaba.cloud.nacos.NacosConfigManager;&#13;
import com.alibaba.nacos.api.config.listener.Listener;&#13;
import com.alibaba.nacos.api.exception.NacosException;&#13;
import com.hmall.common.utils.CollUtils;&#13;
import lombok.RequiredArgsConstructor;&#13;
import lombok.extern.slf4j.Slf4j;&#13;
import org.springframework.cloud.gateway.route.RouteDefinition;&#13;
import org.springframework.cloud.gateway.route.RouteDefinitionWriter;&#13;
import org.springframework.stereotype.Component;&#13;
import reactor.core.publisher.Mono;&#13;
&#13;
import javax.annotation.PostConstruct;&#13;
import java.util.HashSet;&#13;
import java.util.List;&#13;
import java.util.Set;&#13;
import java.util.concurrent.Executor;&#13;
&#13;
@Component&#13;
@RequiredArgsConstructor&#13;
@Slf4j&#13;
public class DynamicRouterConfig {&#13;
    // nacos 配置管理器 ， 在底层这个类已经注册成了 Bean , 而这类的 getConfigService方法就可以获取 ConfigService  ，nacos 的连接对象&#13;
    private final NacosConfigManager nacosConfigManager;&#13;
&#13;
    //  操作路由表的对象 ，新增或者删除路由 &#13;
    private final RouteDefinitionWriter routeDefinitionWriter;&#13;
   // nacos 中配置文件的名字&#13;
    private final String dataId = 'gateway-router.json';&#13;
  // 组名&#13;
    private final String group = 'DEFAULT_GROUP';&#13;
  // 保存每一次更新后的路由 id &#13;
    private final Set&lt;String&gt; routerIds = new HashSet&lt;&gt;();&#13;
&#13;
    @PostConstruct // 在构造方法执行之后立刻执行&#13;
    public void initRouter() throws NacosException {&#13;
        // 第一次获取的到的路由配置信息&#13;
        String configInfo = nacosConfigManager.getConfigService()&#13;
       // 先拉取一次配置，后再监听配置 参数： 配置文件名、组别、超时时间 、监听器&#13;
       .getConfigAndSignListener(&#13;
                dataId, group, 5000,&#13;
                new Listener() {&#13;
                    /**&#13;
                     * 利用线程池技术来进行下面的 receiveConfigInfo 方法&#13;
                     * @return&#13;
                     */&#13;
                    @Override&#13;
                    public Executor getExecutor() {&#13;
                        return null;&#13;
                    }&#13;
&#13;
                    /**&#13;
                     * 监听到路由变化执行的函数&#13;
                     * @param configInfo 配置信息&#13;
                     */&#13;
                    @Override&#13;
                    public void receiveConfigInfo(String configInfo) {&#13;
                        // 动态加载路由&#13;
                        updateRouter(configInfo);&#13;
                    }&#13;
                });&#13;
        //  先更新一次路由表，后面通过监听器来更新路由表&#13;
        updateRouter(configInfo);&#13;
&#13;
    }&#13;
&#13;
    /**&#13;
     * 更新路由表&#13;
     *&#13;
     * @param configInfo ， 路由的配置信息&#13;
     */&#13;
    public void updateRouter(String configInfo) {&#13;
        log.info('路由配置信息： {}', configInfo);&#13;
        // 获取到的 configInfo 是一个 json 格式的数组对象，对象的属性是 id、route、predicates、filters ，&#13;
        // 正好 RouteDefinition 类就是这么定义的，所以可以直接转换成 RouteDefinition 对象&#13;
        // 1. 将路由信息转换为 RouteDefinition 对象集合&#13;
        List&lt;RouteDefinition&gt; routeDefinitionList = JSONUtil.toList(configInfo, RouteDefinition.class);&#13;
&#13;
        // 2. 在更新路由表之前应该将旧的路由表的所有路由删除掉&#13;
        for (String routerId : routerIds) {&#13;
            routeDefinitionWriter.delete(Mono.just(routerId)).subscribe();&#13;
        }&#13;
        // 2.1 清空已经删除的路由id ，防止去删除上一次更新的路由&#13;
        routerIds.clear();&#13;
&#13;
        // 3. 将路由信息更新到 Gateway&#13;
        if (CollUtils.isEmpty(routeDefinitionList)) return;&#13;
&#13;
        for (RouteDefinition routeDefinition : routeDefinitionList) {&#13;
            // 更新路由表，并且订阅&#13;
            routeDefinitionWriter.save(Mono.just(routeDefinition)).subscribe();&#13;
            // 记录更新的路由 id ，以便下一次更新路由是将旧的路由删除&#13;
            routerIds.add(routeDefinition.getId());&#13;
        }&#13;
    }&#13;
&#13;
}&#13;
&#13;
````。</description><guid isPermaLink="true">https://2004GIF.github.io/chenzian-shrimp.github.io/post/wang-guan---dong-tai-lu-you.html</guid><pubDate>Fri, 28 Jun 2024 11:37:14 +0000</pubDate></item><item><title>微服务-网关实现登录校验</title><link>https://2004GIF.github.io/chenzian-shrimp.github.io/post/wei-fu-wu---wang-guan-shi-xian-deng-lu-xiao-yan.html</link><description># 微服务-网关&#13;
## 利用微服务网关实现登录认证&#13;
流程图&#13;
![wfw](https://github.com/2004GIF/chenzian-shrimp.github.io/assets/126451952/0df00b44-a517-4859-a8e9-844f302068c4)&#13;
&#13;
1. 自定义GlobalFilter&#13;
````java&#13;
/**&#13;
 * 认证过滤器&#13;
 */&#13;
@Component&#13;
@RequiredArgsConstructor&#13;
public class AuthGlobalFilter implements GlobalFilter, Ordered {&#13;
&#13;
    private final AuthProperties authProperties;&#13;
&#13;
    private final JwtTool jwtTool;&#13;
    /**&#13;
     * 利用 spring 提供的路径匹配器来校验请求是否需要拦截&#13;
     */&#13;
    private final AntPathMatcher antPathMatcher = new AntPathMatcher();&#13;
&#13;
    @Override&#13;
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {&#13;
        // 1. 获取请求对象&#13;
        ServerHttpRequest request = exchange.getRequest();&#13;
        // 2. 判断请求的路径是否需要拦截&#13;
        if (isExclude(request.getPath().toString())) {&#13;
            // 不需要拦截放行&#13;
            return chain.filter(exchange);&#13;
        }&#13;
        // 3. 获取token ，进行校验&#13;
        HttpHeaders headers = request.getHeaders();&#13;
        List&lt;String&gt; values = headers.get(HttpHeaders.AUTHORIZATION);&#13;
        String token = null;&#13;
        // 3.1 token 不为空，获取 token&#13;
        if (values != null &amp;&amp; CollUtil.isNotEmpty(values)) {&#13;
            token = values.get(0);&#13;
        }&#13;
        Long userId = null;&#13;
        // 3.2 校验 token&#13;
        try {&#13;
            userId = jwtTool.parseToken(token);&#13;
        } catch (Exception e) {&#13;
            e.printStackTrace();&#13;
            // token 校验失败拦截&#13;
            ServerHttpResponse response = exchange.getResponse();&#13;
            response.setStatusCode(HttpStatus.UNAUTHORIZED);&#13;
           // response.setComplete() 将请求拦截&#13;
            return response.setComplete();&#13;
        }&#13;
&#13;
        //  4. 向下游传递用户数据 (  利用请求头来向下传递用户信息 )&#13;
        Long finalUserId = userId;&#13;
        // 4. 改变网关中传递下去的上下文对象  mutate 突变&#13;
        ServerWebExchange swc = exchange.mutate()&#13;
                .request(builder -&gt;&#13;
                        builder.header(CommonConstant.HEADER_USER_INFO, String.valueOf(finalUserId))&#13;
                ).build();&#13;
        // 5. 放行&#13;
        return chain.filter(swc);&#13;
    }&#13;
&#13;
    /**&#13;
     * 判断请求是否需要拦截&#13;
     * true 代表不需要拦截&#13;
     * false 代表拦截&#13;
     *&#13;
     * @param path 请求路径&#13;
     * @return&#13;
     */&#13;
    private boolean isExclude(String path) {&#13;
        System.out.println('path = ' + path);&#13;
        // 如果需要排除的请求集合为空，直接返回false&#13;
        if (CollUtil.isEmpty(authProperties.getExcludePaths())) return false;&#13;
&#13;
        for (String excludePath : authProperties.getExcludePaths()) {&#13;
            if (antPathMatcher.match(excludePath, path)) {&#13;
                return true;&#13;
            }&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    @Override&#13;
    public int getOrder() {&#13;
        return 0;&#13;
    }&#13;
}&#13;
````&#13;
&#13;
2. 抽取一个公共的模块这个这个模块被微服务引用，在这个微服务中定义一个拦截器，这个拦截器作用就是拦截网关转发的请求，获取请求中请求头中的用户信息，存储到线程对象中&#13;
````java&#13;
&#13;
public class UserInfoInterceptor implements HandlerInterceptor {&#13;
    /**&#13;
     * 到达请求资源之前&#13;
     * 需要做的事 ： 将用户信息存储到 ThreadLocal 中&#13;
     *&#13;
     * @param request&#13;
     * @param response&#13;
     * @param handler&#13;
     * @return&#13;
     * @throws Exception&#13;
     */&#13;
    @Override&#13;
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {&#13;
        // 1. 获取用户信息&#13;
        String userId = request.getHeader(CommonConstant.HEADER_USER_INFO);&#13;
&#13;
        // 2. 将用户信息存储到 ThreadLocal 中&#13;
        if (StrUtil.isNotBlank(userId)) {&#13;
            UserContext.setUser(Long.valueOf(userId));&#13;
        }&#13;
&#13;
        // 3. 放行&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * 完成请求后&#13;
     *&#13;
     * @param request  请求&#13;
     * @param response&#13;
     * @param handler&#13;
     * @param ex&#13;
     * @throws Exception 需要做的事清空请求头中用户数据&#13;
     *                   原因： 确保每一次请求处理的上下文隔离，保持系统的稳定性和安全性&#13;
     *                   如果不删除：当前服务被其他微服务调用导致线程池中的线程被复用，导致线程中存储了上一次请求的用户信息，请求数据是错误的&#13;
     */&#13;
    @Override&#13;
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {&#13;
        UserContext.removeUser();&#13;
    }&#13;
}&#13;
````&#13;
3. 在公共模块中配置这个拦截到 spring mvc 中&#13;
````java&#13;
@Configuration&#13;
// 在所有的 springMvc 工程中都存在 DispatcherServlet&#13;
// 只有 DispatcherServlet 类存在时，才会执行下面的配置&#13;
@ConditionalOnClass(DispatcherServlet.class)&#13;
public class WebConfig implements WebMvcConfigurer {&#13;
    /**&#13;
     * 添加拦截器&#13;
     * @param registry&#13;
     */&#13;
    @Override&#13;
    public void addInterceptors(InterceptorRegistry registry) {&#13;
        registry.addInterceptor(new UserInfoInterceptor());&#13;
    }&#13;
}&#13;
````&#13;
注意在这里定义的配置默认是对其他模块没有效果的  （默认的springboot 工程只会将启动类所在的包或者子包扫描到） ，需要利用 springboot 自动装 , 在 resources  创建一个  META-INF/spring.factories   实现自动装配&#13;
````factories &#13;
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\&#13;
  com.hmall.common.config.MyBatisConfig,\&#13;
  com.hmall.common.config.WebConfig,\&#13;
  com.hmall.common.config.JsonConfig&#13;
````&#13;
&#13;
4. 微服务直接相互调用在 请求头中携带用户信息 &#13;
   - 1. 在 公共的api 模块中创建一个类实现 RequestInterceptor 接口&#13;
   - 2. apply方法中利用 RequestTemplate 将存储到线程对象中的用户信息设置给请求头&#13;
  ```java&#13;
  //  这里才有了匿名类来实现本质要一样的&#13;
    @Bean&#13;
    public RequestInterceptor userInfoRequestInterceptor() {&#13;
        return new RequestInterceptor() {&#13;
            @Override&#13;
            public void apply(RequestTemplate requestTemplate) {&#13;
                // 1. 从线程对象中获取用户信息&#13;
                Long userInfo = UserContext.getUser();&#13;
                // 2. 将用户信息设置到请求头中&#13;
                if (userInfo != null) {&#13;
                    requestTemplate.header(CommonConstant.HEADER_USER_INFO, userInfo.toString());&#13;
                }&#13;
            }&#13;
        };&#13;
    }&#13;
 ````&#13;
5. 在服务中就可以通过线程对象来获取当前的用户信息了&#13;
```java&#13;
    @Override&#13;
    public List&lt;CartVO&gt; queryMyCarts() {&#13;
        // 1.查询我的购物车列表&#13;
        List&lt;Cart&gt; carts = lambdaQuery().eq(Cart::getUserId, UserContext.getUser()).list();&#13;
        if (CollUtils.isEmpty(carts)) {&#13;
            return CollUtils.emptyList();&#13;
        }&#13;
&#13;
        // 2.转换VO&#13;
        List&lt;CartVO&gt; vos = BeanUtils.copyList(carts, CartVO.class);&#13;
&#13;
        // 3.处理VO中的商品信息&#13;
        handleCartItems(vos);&#13;
&#13;
        // 4.返回&#13;
        return vos;&#13;
    }&#13;
```&#13;
。</description><guid isPermaLink="true">https://2004GIF.github.io/chenzian-shrimp.github.io/post/wei-fu-wu---wang-guan-shi-xian-deng-lu-xiao-yan.html</guid><pubDate>Fri, 28 Jun 2024 04:24:18 +0000</pubDate></item><item><title>微服务</title><link>https://2004GIF.github.io/chenzian-shrimp.github.io/post/wei-fu-wu.html</link><description># 微服务&#13;
&#13;
## 微服务与单体架构&#13;
&#13;
微服务是一种软件架构风格，它是以专注于单一职责的很多小型项目为基础，组合出复杂的大型应用。</description><guid isPermaLink="true">https://2004GIF.github.io/chenzian-shrimp.github.io/post/wei-fu-wu.html</guid><pubDate>Thu, 27 Jun 2024 04:23:52 +0000</pubDate></item></channel></rss>